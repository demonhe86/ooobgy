基本原理
　　该算法是通过给每个顶点一个标号（叫做顶标）来把求最大权匹配的问题转化为求完备匹配的问题的。设顶点Xi的顶标为A[ i ]，顶点Yj的顶标为B[ j ]，顶点Xi与Yj之间的边权为w[i,j]。在算法执行过程中的任一时刻，对于任一条边(i,j)，A[ i ]+B[j]>=w[i,j]始终成立。

　　KM算法的正确性基于以下定理：

　　若由二分图中所有满足A[ i ]+B[j]=w[i,j]的边(i,j)构成的子图（称做相等子图）有完备匹配，那么这个完备匹配就是二分图的最大权匹配。

　　这个定理是显然的。因为对于二分图的任意一个匹配，如果它包含于相等子图，那么它的边权和等于所有顶点的顶标和；如果它有的边不包含于相等子图，那么它的边权和小于所有顶点的顶标和。所以相等子图的完备匹配一定是二分图的最大权匹配。

　　初始时为了使A[ i ]+B[j]>=w[i,j]恒成立，令A[ i ]为所有与顶点Xi关联的边的最大权，B[j]=0。如果当前的相等子图没有完备匹配，就按下面的方法修改顶标以使扩大相等子图，直到相等子图具有完备匹配为止。

　　我们求当前相等子图的完备匹配失败了，是因为对于某个X顶点，我们找不到一条从它出发的交错路。这时我们获得了一棵交错树，它的叶子结点全部是X顶点。现在我们把交错树中X顶点的顶标全都减小某个值d，Y顶点的顶标全都增加同一个值d，那么我们会发现：

　　1）两端都在交错树中的边(i,j)，A[ i ]+B[j]的值没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图。

　　2）两端都不在交错树中的边(i,j)，A[ i ]和B[j]都没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图。

　　3）X端不在交错树中，Y端在交错树中的边(i,j)，它的A[ i ]+B[j]的值有所增大。它原来不属于相等子图，现在仍不属于相等子图。

　　4）X端在交错树中，Y端不在交错树中的边(i,j)，它的A[ i ]+B[j]的值有所减小。也就说，它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。

　　现在的问题就是求d值了。为了使A[ i ]+B[j]>=w[i,j]始终成立，且至少有一条边进入相等子图，d应该等于：

　　Min{A[ i ]+B[j]-w[i,j] | Xi在交错树中，Yi不在交错树中}。

改进
　　以上就是KM算法的基本思路。但是朴素的实现方法，时间复杂度为O(n4)——需要找O(n)次增广路，每次增广最多需要修改O(n)次顶标，每次修改顶标时由于要枚举边来求d值，复杂度为O(n2)。实际上KM算法的复杂度是可以做到O(n3)的。我们给每个Y顶点一个“松弛量”函数slack，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边(i,j)时，如果它不在相等子图中，则让slack[j]变成原值与A[ i ]+B[j]-w[i,j]的较小值。这样，在修改顶标时，取所有不在交错树中的Y顶点的slack值中的最小值作为d值即可。但还要注意一点：修改顶标后，要把所有的不在交错树中的Y顶点的slack值都减去d。

 

 

bool find(int x)
{//匈牙利算法寻找x的增广路径 
//以x为根的M的交错树 
//看来本算法需要二部图两部分的顶点个数都相等吧 
    int y, t;
    visitx[x] = true;
    for( y = 0; y < N; y++ )
    {
       if( visity[y] ) continue;//找增广路径的过程中不妨问已经访问过的顶点 
       t = lx[x] + ly[y] - w[x][y];//是在等子图中寻找匹配的增广路径 
       if( t == 0 )
       {
          visity[y] = true;
          if( linky[y] == -1 || find(linky[y]) )
          {
             linky[y] = x;
             return true;
          }
       }
        else
        {//因为本来就需要将一条x顶点在交错树中，y顶点不在交错树中的边扩展进交错树来
        //所以只改变这些不在等子图中的边的y顶点的松弛量 
           if( slack[y] > t )
           slack[y]=t;
        }
     }
     return false;
}
//外层的匈牙利算法需要O(2)的时间，而修改顶标时由于要枚举所有的边所以也需要O(2)的时间
//所以总时间是O(4) 
//引入松弛量以后改变顶标就不需要枚举每一条边，只需要枚举不在交错树中的y的松弛量，所以
//时间复杂度降为O(3) 
void KM()
{//KM算法寻找图的最大权匹配 
     int i, j, x, d;
     memset(linky,-1,sizeof(linky));
     memset(lx,0,sizeof(lx)); //x的顶标 
     memset(ly,0,sizeof(ly));//y的顶标 
     for( i = 0; i < N; i++)
        for( j = 0; j < N; j++ )
           if( map[i][j] > lx[i] )
             lx[i] = map[i][j];//一开始x的顶标为所有与x相连的边中权值最大的边的权值，y的顶标为0 
        for( x = 0; x < N; x++ )
        {//在匈牙利算法中从每个x出发寻找增广路，如果找到就在匹配值上加1，这是为了寻找最大匹配
        //而在此处，必须找到完备匹配，所以对于每一个x中的顶点，找到其增广路就跳出，找不到的话
        //就需要修改顶标值直至找到为止 
            for( i = 0; i < N; i++ )
               slack[i] = INF;//松弛变量 
           while (true)
           {//无限循环直至找到完备匹配 
                memset(visitx, 0, sizeof(visitx));//visx为真表示的是该顶点是匹配中的顶点 
                memset(visity, 0, sizeof(visity));//y同理 
                if( find(x) ) break;
                d = INF;
                for( i = 0; i < N; i++) 
                {
                   if ( !visity[i] )//注意是取所有不在交错树中的y顶点的松弛量的最小值作为d的值 
                     if ( d > slack[i] )
                        d = slack[i];
                }
                for( i = 0; i < N; i++ )
                {
                   if( visitx[i] )
                     lx[i] -= d;
                }
                for( i = 0; i < N; i++ )
                {
                   if( visity[i] )
                   ly[i] += d;
                   else
                   slack[i] -= d;
                }
            }
        }
}

　　Kuhn－Munkras算法流程：

　　(1)初始化可行顶标的值

　　(2)用匈牙利算法寻找完备匹配

　　(3)若未找到完备匹配则修改可行顶标的值

　　(4)重复(2)(3)直到找到相等子图的完备匹配为止
